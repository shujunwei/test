#!/usr/bin/env python
# -*- coding: UTF-8 -*-
'''
@Project ：test 
@File    ：运算符.py
@Author  ：Administrator
@Date    ：2020/10/29 10:14 
'''


'''
运算符

Python 语言支持以下类型的运算符:
算术运算符
比较（关系）运算符
赋值运算符
逻辑运算符
位运算符
成员运算符
身份运算符
运算符优先级
'''
#***********************************************************************************************************************
# 算术运算符

'''
以下假设变量a为10，变量b为21：

运算符	描述	                                                     实例
+	    加 - 两个对象相加             	                         a + b 输出结果 31
-	    减 - 得到负数或是一个数减去另一个数	                     a - b 输出结果 -11
*	    乘 - 两个数相乘或是返回一个被重复若干次的字符串	             a * b 输出结果 210
/	    除 - x 除以 y	                                         b / a 输出结果 2.1
%	    取模 - 返回除法的余数	                                     b % a 输出结果 1
**	    幂 - 返回x的y次幂	                                         a**b 为10的21次方
//	    取整除 - 向下取接近商的整数	                             9//2  = 4   -9//2 = -5

'''
# a = 21
# b = 10
# c = 0
#
# c = a + b
# print("a + b 的值为：", c)
#
# c = a - b
# print("a - b 的值为：", c)
#
# c = a * b
# print("a * b的值为：", c)
#
# c = a / b
# print("a / b 的值为：", c)
#
# c = a % b
# print("a % b 的值为：", c)



#***********************************************************************************************************************
# 比较（关系）运算符
'''
运算符	描述	                                                           实例
==	    等于 - 比较对象是否相等	                                       (a == b) 返回 False。
!=	    不等于 - 比较两个对象是否不相等	                               (a != b) 返回 True。
>	    大于 - 返回x是否大于y	(a > b) 返回 False。
<	    小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。
		这分别与特殊的变量True和False等价。注意，这些变量名的大写。	       (a < b) 返回 True。
>=	    大于等于 - 返回x是否大于等于y。	                               (a >= b) 返回 False。
<=	    小于等于 - 返回x是否小于等于y。	                               (a <= b) 返回 True。
'''

# 以下假设变量a为10，变量b为20：

a = 21
b = 10
c = 0

# if (a == b):
#     print("a 等于 b")
# else:
#     print("a 不等于 b")
#
# if (a != b):
#     print("a 不等于 b")
# else:
#     print("a 等于 b")
#
# if (a < b):
#     print("a 小于 b")
# else:
#     print("a 大于等于 b")
#
# if (a > b):
#     print("a 大于 b")
# else:
#     print("a 小于等于 b")




#***********************************************************************************************************************
# 赋值运算符
'''
假设变量a为10，变量b为20：
运算符	描述                  	 实例
=	    简单的赋值运算符	     c = a + b 将 a + b 的运算结果赋值为 c
+=	    加法赋值运算符	         c += a 等效于 c = c + a
-=	    减法赋值运算符	         c -= a 等效于 c = c - a
*=	    乘法赋值运算符	         c *= a 等效于 c = c * a
/=	    除法赋值运算符	         c /= a 等效于 c = c / a
%=	    取模赋值运算符	         c %= a 等效于 c = c % a
**=	    幂赋值运算符	         c **= a 等效于 c = c ** a
//=	    取整除赋值运算符	     c //= a 等效于 c = c // a
'''

a = 21
b = 10
c = 0

# c = a + b
# print("a + b 的值为：", c)
#
# c += a
# print("c + a 的值为：", c)
#
# c *= a
# print("c * a 的值为：", c)
#
# c /= a
# print("c / a 的值为：", c)
#
# c = 2
# c %= a
# print("c % a 的值为：", c)
#
# c **= a
# print("c ** a 的值为：", c)
#
# c //= a
# print("c // a 的值为：", c)



#***********************************************************************************************************************
# 逻辑运算符

'''
逻辑运算符的本质
在 Python 中，and 和 or 不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。

另外，and 和 or 运算符会将其中一个表达式的值作为最终结果，而不是将 True 或者 False 作为最终结果。

以上两点极其重要，了解这两点不会让你在使用逻辑运算的过程中产生疑惑。

对于 and 运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 Python 按照下面的规则执行 and 运算：
如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时 and 会把左边表达式的值作为最终结果。
如果左边表达式的值为真，那么最终值是不能确定的，and 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

对于 or 运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行 or 运算：
如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时 or 会把左边表达式的值作为最终结果。
如果左边表达式的值为假，那么最终值是不能确定的，or 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。


逻辑运算符	含义	                              基本格式	说明
and	        逻辑与运算，等价于数学中的“且”	      a and b	当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。
or	        逻辑或运算，等价于数学中的“或”	      a or b	当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。
not	        逻辑非运算，等价于数学中的“非”	      not a	    如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反



'''
#
# a = 10
# b = 20
#
# if (a<5 and b>a):
#     print("都为 true")
# else:
#     print("有一个不为 true")
#
# if (a < 5 or b>a):
#     print("其中一个变量为 true")
# else:
#     print("都不为 true")


#***********************************************************************************************************************
# 位运算符

'''
位运算符

运算符	描述	                                                                                        实例
&	    按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0   	                    (a & b) 输出结果 12 ，二进制解释： 0000 1100
|	    按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。	                                    (a | b) 输出结果 61 ，二进制解释： 0011 1101
^	    按位异或运算符：当两对应的二进位相异时，结果为1	                                                (a ^ b) 输出结果 49 ，二进制解释： 0011 0001
~	    按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1	                    (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。
<<	    左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。	    a << 2 输出结果 240 ，二进制解释： 1111 0000
>>	    右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数	            a >> 2 输出结果 15 ，二进制解释： 0000 1111


按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：
下表中变量 a 为 60，b 为 13二进制格式如下：
a = 0011 1100
b = 0000 1101

a&b = 0000 1100        与（&），按位与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0

a|b = 0011 1101        或（|），按位或运算符：只要对应的两个二进位有一个为1时，结果位就为1

a^b = 0011 0001        异或（^）,按位异或运算符：当两对应的二进位相异时，结果为1

~a  = 1100 0011       取反（~），按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1

左位移（<<）,运算数的各二进位全部左移若干位，由<<右边的数字指定了移动的位数，高位丢弃，低位补0
右位移（>>）,把‘>>’左边的运算数的各二进制位全部右移若干位，>>右边的数字指定了移动的位数
'''

# print(int('00001100',2))
#
# a = 60  # 60 = 0011 1100
# b = 13  # 13 = 0000 1101
# c = 0
#
# c = a & b  # 12 = 0000 1100
# print("a & b 的值为：", c)
#
# c = a | b  # 61 = 0011 1101
# print("a | b 的值为：", c)
#
# c = a ^ b  # 49 = 0011 0001
# print("a ^ b  的值为：", c)
#
# c = ~a  # -61 = 1100 0011
# print(" ~a 的值为：", c)
#
# c = a << 2  # 240 = 1111 0000
# print("a << 2  的值为：", c)
#
# c = a >> 2  # 15 = 0000 1111
# print("a >> 2 的值为：", c)
#***********************************************************************************************************************
# 成员运算符,测试实例中包含了一系列的成员，包括字符串，列表或元组。

'''
运算符	描述	                                                实例
in	    如果在指定的序列中找到值返回 True，否则返回 False。	    x 在 y 序列中 , 如果 x 在 y 序列中返回 True。
not in	如果在指定的序列中没有找到值返回 True，否则返回 False。	x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。
'''

# a = 10
# b = 20
# list = [1, 2, 3, 4, 5]
#
# if (a in list):
#     print(变量 a 在给定的列表中 list 中")
# else:
#     print(变量 a 不在给定的列表中 list 中")
#
# if (b not in list):
#     print("变量 b 不在给定的列表中 list 中")
# else:
#     print("变量 b 在给定的列表中 list 中")
#
# # 修改变量 a 的值
# a = 2
# if (a in list):
#     print("变量 a 在给定的列表中 list 中")
# els
#     print("变量 a 不在给定的列表中 list 中")
#***********************************************************************************************************************
# 身份运算符
'''
身份运算符用于比较两个对象的存储单元

运算符	描述	                                          实例
is	    is  是判断两个标识符是不是引用自一个对象	      x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False
is not	is not 是判断两个标识符是不是引用自不同对象       x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。
'''

# 注： id() 函数用于获取对象内存地址。


# a = 20
# b = 20
#
# if (a is b):
#     print("1 - a 和 b 有相同的标识")
# else:
#     print("1 - a 和 b 没有相同的标识")
#
# if (id(a) == id(b)):
#     print("2 - a 和 b 有相同的标识")
# else:
#     print("2 - a 和 b 没有相同的标识")
#
# # 修改变量 b 的值
# b = 30
# if (a is b):
#     print("3 - a 和 b 有相同的标识")
# else:
#     print("3 - a 和 b 没有相同的标识")
#
# if (a is not b):
#     print("4 - a 和 b 没有相同的标识")
# else:
#     print("4 - a 和 b 有相同的标识")

'''
is和==的区别
python中对象包含三种基本要素：id(返回的是对象的地址)、type(返回的是对象的数据类型)及value(对象的值)。
is和==都可以对两个对象进行比较，而且它们的返回值都是布尔类型。但是它们比较的内容是不同的，不然两个函数的作用就重复了。首先我们来看下例子，从实际操作中来看下二者的区别。
'''

# a = [1,2,3]
# b = [1,2,3]
# print(id(a))
# print(id(b))
# print(a == b)
# print(a is b)
# 从上面的例子可以得出，is和==比较的对象的内容时不同的，即：is比较的是两个对象的地址值，也就是说两个对象是否为同一个实例对象；而==比较的是对象的值是否相等
# 那么怎么才能让两个对象的地址值相等呢，如果想让一个对象ls2 is ls1返回True应该怎么操作呢，我们可以把ls1赋值给ls2，这样ls1和ls2指向的就是同一个内存地址，ls1 == ls2和ls1 is ls2返回的都是True。

# a = [1,2,3]
# b = a
# print(id(a))
# print(id(b))
# print(a == b)
# print(a is b)




#***********************************************************************************************************************
# 运算符优先级
'''
以下表格列出了从最高到最低优先级的所有运算符：

运算符	                    描述
**	                        指数 (最高优先级)
~ + -	                    按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)
* / % //	                乘，除，求余数和取整除
+ -	                        加法减法
>> <<	                    右移，左移运算符
&	                        位 'AND'
^ |	                        位运算符
<= < > >=	                比较运算符
== !=	                    等于运算符
= %= /= //= -= += *= **=	赋值运算符
is is not	                身份运算符
in not in	                成员运算符
not and or	                逻辑运算符
'''

# a = 20
# b = 10
# c = 15
# d = 5
# e = 0
#
# e = (a + b) * c / d  # ( 30 * 15 ) / 5
# print("(a + b) * c / d 运算结果为：", e)
#
# e = ((a + b) * c) / d  # (30 * 15 ) / 5
# print("((a + b) * c) / d 运算结果为：", e)
#
# e = (a + b) * (c / d)  # (30) * (15/5)
# print("(a + b) * (c / d) 运算结果为：", e)
#
# e = a + (b * c) / d  # 20 + (150/5)
# print("a + (b * c) / d 运算结果为：", e)








#***********************************************************************************************************************

# 赋值(=)、浅拷贝(copy())、深拷贝(deepcopy())

'''
赋值其实就是对对象的直接引用。
'''
# ls = [1,2,3]
# ls1 = ls
#
# print(id(ls))
# print(id(ls1))
#
# ls.append(99)
# print(ls)
# print(ls1)

# ls = ls1赋值引用，ls和ls1都指向同一个对象。


'''
浅拷贝(copy())：拷贝父对象，不会拷贝对象内部的子对象。例子如下：
'''

# ls = [1,2,3]
# ls1 = ls.copy()
#
# print(id(ls))
# print(id(ls1))
#
# ls.append(99)
# print(ls)
# print(ls1)
# 对列表ls进行 浅拷贝copy(),可以看到拷贝后的地址值是不一样的，对ls进行append(),不会改变ls1的值；

# 但是在上面的例子中看不出子对象父对象关系，那我们用下面这个例子：

# dic = {10:[1,2,3]}
# dic1 = dic.copy()
#
# print(id(dic))
# print(id(dic1))
#
# dic[10].append(100)
# print(dic)
# print(dic1)
#
# dic1[10] = [10,20]
# print(dic)
# print(dic1)

# dic1 = dic.copy()：dic和dic1是独立的对象，但是它们的子对象[1,2,3,4]还是指向统一的对象。

'''
深拷贝(deepcopy())：是copy模块中的方法，完全拷贝了子对象和父对象，例子如下：

'''


#***********************************************************************************************************************
#***********************************************************************************************************************
#***********************************************************************************************************************
